ejercicio 1:
maximo del arreglo
array = [3, 1, 4, 1, 5, 9, 2, 6]

def max_array(array, length)
    i = 0
    max = 0
    while i < length
        if(max < array[i])
            max = array[i]
        i++
    return max

assembler: 
.text:
la a0, array
lw a1, length
jal ra, max_array

li a7, 4 #printea
ecall

li a7, 93 #stopea
ecall

max_array:
    li t0, 0 #iterador de ciclo
    lw t1, 0(a0) #maximo
    
while:
    bge t0, a1, return
    lw t2, 0(a0)
    bge t2, t1, max
    addi a0, a0, 4
    addi t0, t0, 1
    j while
        
max: 
    lw t1, 0(a0)
    addi a0, a0, 4
    addi t0, t0, 1
    j while
        
return:
    mv a0, t1
    ret


ejercicio 2:
dado q y s vectores, copia q en s

def copia_array(q, s, length)
    i = 0
    while(i < length)
        s[i] = q[i]
    return s

assembler: 
.text:
la a0, arrayS
la a1, arrayQ
lw a2, length
jal ra, copia_array

li a7, 4 #printea
ecall

li a7, 93 #stopea
ecall

copia_array:
li t0, 0 #i = 0

while:
bge t0, a2, return
lw t1, 0(a1)
sw t1, 0(a0)
addi t0, t0, 1
addi a1, a1, 4
addi a0, a0, 4
j while
        
return:
    mv a0, t1
    ret

.data: 
arrayS: .word 0x00000003 0x00000001 0x00000004 0x00000001 
arrayQ: .word 0x00000005 0x00000003 0x00000001 0x00000001 
length: .word 0x00000004


Ejercicio 3:
copiar q en s, solo si el elem de q es par
def copia_par_array(q, s, length)
    i = 0
    while(i < length)
        if(q[i] % 2 == 0){
            s[i] = q[i]
        }
    return s

assembler:
.text:
la a0, arrayS
la a1, arrayQ
lw a2, length
jal ra, copia_par_array

li a7ddi sp, sp, -12, 4 #printea
ecall

li a7, 93 #stopea
ecall


copia_par_array:
li t0, 0 #i = 0


while:
bge t0, a2, return
lw t1, 0(a1)

            
andi t2, t1, 1 #hago mascara a t1 (q[i]) para saber si es par
                
beq t2, x0, reemplazo # si es par lo pongo en s  
addi t0, t0, 1
addi a1, a1, 4
addi a0, a0, 4
j while

reemplazo: 
sw t1, 0(a0)
addi t0, t0, 1
addi a1, a1, 4
addi a0, a0, 4
j while
    
return:
    mv a0, t1
    ret

.data: 
arrayS: .word 0x00000003 0x00000001 0x00000004 0x00000005 
arrayQ: .word 0x00000004 0x00000002 0x00000001 0x00000001 
length: .word 0x00000004

ejercicio 4:

def binary_search (array, elem, length)
    int arriba = length - 1
    int abajo = 0
    int medio 
    while(abajo <= arriba)
        medio = abajo + (arriba - abajo)/2 # si lo hciera mal como fausto, se me podria ir de rango (32 bts)

        if(array[medio] = elem)
            return medio

        if(array[medio] < elem)
            abajo = medio + 1
        else 
            arriba = medio - 1
    return medio

assembler:

.text:
la a0, array
lw a1, target
jal ra, binary_search

li a7, 4 #printea
ecall

li a7, 93 #stopea
ecall

binary_search:
li t0, 0 #abajo
lw t1, length 
addi t1, t1, -1 #arriba = length - 1

while:
mv t2, t0 #t2 = abajo
mv t5, t1 # t5 = arriba
sub t6, t5, t0 #t5 = arriba - abajo
srli t5, t6, 1 #t5 = (arriba - abajo)/2  toma floor
add t2, t0, t5 #medio(t2) = abajo + (arriba - abajo)/2 
                

slli t3, t2, 2 # t3 = medio*4
add a0, a0, t3 # a0 = a0 + t3

lw t4, 0(a0)  # t4 = array[medio]
beq t4, a1, return  # t4 = a1 -> return

blt t4, a1, caso  # t4 < a1 -> medio_es_abajo
 
sub a0, a0, t3 # a0 = a0 - t3
addi t1, t2, -1 # arriba = medio - 1
j while

caso:
sub a0, a0, t3 # a0 = a0 - t3
addi t0, t2, 1 #abajo = medio + 1
j while
    
return:
    mv a0, t2 #devuelvo medio (t2)
    ret

.data: 
array: .word 1 3 5 7 9 11 13 15 17 19
target: .word 15
length: .word 10


ejercicio 5:

def fibonacci(n):
    if n == 1:
        return 1
    if n == 0:
        return 0
    else:
        a = n-1
        b = n-2
        return fibonacci(a) + fibonacci(b)

assembler:
.text:
lw a0, numero
jal ra, fibonacci

li a7, 1 #printea
ecall

li a7, 93 #stopea
ecall

fibonacci:
addi sp, sp, -12 #hago 3 espacios en el stack, empieza desde arriba por eso resto
sw ra , 0(sp)
sw a0,  4(sp)

addi t0 , zero , 1
beq t0, a0, then1
beq x0, a0, then2
#else
addi a0, a0, -1
jal ra, fibonacci
sw a0, 8(sp) #guardo el resultado de fibonacci(n-1)


lw a0, 4(sp) #restauro a0 = n
addi a0, a0, -2
jal ra, fibonacci
sw a0, 4(sp) #guardo el resultado de fibonacci(n-2) 

lw t1, 4(sp) 
lw t2, 8(sp)
lw ra, 0(sp)
add t1, t1, t2


add a0 , t1 , x0

return:
addi sp , sp , 12
ret


then1:
    lw ra, 0(sp)
addi sp , sp , 12
ret
    
then2:
    lw ra, 0(sp)
addi sp , sp , 12
ret

.data: 
numero: .word 5

ejercicio 6:
a-
def mul(n, m)
    i = 0
    total = 0
    while(i!=n)
        total += n
        i += 1
    return total

b- 
def factorial(n)
    if(n == 0)
        return 1
    else
        return mul(n, facttorial(n-1))
    
.text:
lw a0, numero
jal ra, factorial

li a7, 1 #printea
ecall

li a7, 93 #stopea
ecall

mul:
li t0, 0
li t3, 0 #acumulador
j whileW

whileW:
addi t0, t0, 1 #t0 += 1
add t3, t3, a0  

blt t0, t2, whileW #si t0 != t2 -> whileW 

mv a0, t3
ret

factorial:
addi sp, sp, -8
li t1, 1
sw ra, 0(sp)
sw a0, 4(sp)

bgt a0, t1, while # a0 > t1 -> while

#addi a0, a0, 1
ret


while:
addi a0, a0, -1
jal ra, factorial
mv t2, a0
lw t4, 0(sp) #quiero el ra anterior no el del factorial
lw a0, 4(sp) 
addi sp, sp, 8

jal ra, mul #multiplico a0 = t2 * a0
mv ra, t4
jr ra

.data
numero: .word 7

c) el problema es que para


ejercicio 7:
.text:
lw a0, numero
jal ra, sum

li a7, 1 #printea
ecall

li a7, 93 #stopea
ecall


sum:
addi sp, sp, -8
sw ra, 0(sp)
sw a0, 4(sp)

bgt a0, x0, while # a0 > t1 -> while

#addi a0, a0, 1
ret


while:
addi a0, a0, -1
jal ra, sum
mv t2, a0
lw t4, 0(sp) #quiero el ra anterior no el del factorial
lw a0, 4(sp) 
addi sp, sp, 8

add a0, a0, t2
mv ra, t4
jr ra

.data
numero: .word 10

Parcial:
Ejercicio 1

.text:
lw a0, numero
jal ra, impares?

li a7, 1 #printea
ecall

li a7, 93 #stopea
ecall

impares?:
#creo 4 argumentos, y les asigno a cada uno un byte de la palabra
#a cada uno dependiendo de su lugar lo muevo a la derecha de modo
#que quede al principio
#luego a cada uno le hago and con 1, y hago beq a cada uno
#si son iguales a 1 voy a un target que le aÃ±ade 1 a a0

lw a1, mascara1
lw a2, mascara2
lw a3, mascara3
lw a4, mascara4

and t0, a0, a1
and t1, a0, a2
and t2, a0, a3
and t3, a0, a4

srli t3, t3, 24
srli t2, t2, 16
srli t1, t1, 8

andi t0, t0, 1
andi t1, t1, 1
andi t2, t2, 1
andi t3, t3, 1

li t4, 1
li a0, 0

ifs:
 
beq t0, t4, sumo1
beq t1, t4, sumo2
beq t2, t4, sumo3
beq t3, t4, sumo4

ret

sumo1:
addi a0, a0, 1
li t0, 0
j ifs

sumo2:
addi a0, a0, 1
li t1, 0
j ifs

sumo3:
addi a0, a0, 1
li t2, 0
j ifs

sumo4:
addi a0, a0, 1
li t3, 0
j ifs
    
.data
numero: .byte 0x37 0x05 0x01 0x02
mascara1: .byte 0xff 0x00 0x00 0x00
mascara2: .byte 0x00 0xff 0x00 0x00
mascara3: .byte 0x00 0x00 0xff 0x00
mascara4: .byte 0x00 0x00 0x00 0xff 


ejercicio 3:
.text:
la a0, mediciones
lw a1, largo
jal ra, DispMedicion

li a7, 1 #printea
ecall

li a7, 93 #stopea
ecall

DispMedicion:
li t0, 0 #iterador
li s0, 0x0f00 #valor para comparar
li t2, 0 #contador
li t3, 0x0000ffff

while:
lh t1, 0(a0) #indexo y guardo en t1

and t1, t1, t3

beq t0, a1, return #iterador == largo -> return
blt s0, t1, sumo

addi t0, t0, 1
addi a0, a0, 2
j while

sumo:
addi t0, t0, 1
addi t2, t2, 1
addi a0, a0, 2
j while

return:
mv a0, t2
ret
    
.data
mediciones: .half 0x1100 0x00F0 0x0200 0x0010 0x1100
largo: .byte 5




